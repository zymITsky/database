一 数据库五大范式
1 几个基本概念
范式NF（normal forms）：数据库设计中符合某种关系模式的集合。
函数依赖              ：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X
完全函数依赖           ：如果属性或（或者属性组）X能确定Y的值，但是对于X的任何真子集都不能确定Y，那么Y完全依赖X。解释比如（学号、课程编号）能唯一确定成绩，但是学号或课程编号中的任意一个都不能唯一确定成绩。
部分函数依赖           ：关系中的某个属性Y依赖于X，但是又不完全依赖于X，比如成绩依赖于学号，但是又不完全依赖于学号，因为还有依赖于科目，这种关系就是部分依赖
传递函数依赖           ：Z函数依赖于Y，Y函数依赖域X，那么Z就是传递函数依赖于X，比如说工号可以确定部门，而部门又可以确定部长，部长就是传递函数依赖于工号
码                   ：关系中的某个属性或者某几个属性的组合，用于区分每个元组，即主键。

2 范式
第一范式 ：关系中的每个属性都不可再分
第二范式 ：2NF在1NF的基础之上，要求记录有惟一标识，即实体的惟一性，更通俗说有主键。
第三范式 ：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖，必须只依赖于主键。比如一个表中有员工编号、员工姓名、部门、部长，部长依赖于部门，但是这个表的主键是员工编号，所以这是不符合第三范式的。
BC范式  ：满足第三范式的基础上，又要满足，主键不能有函数依赖，即主键有（A、B、C），A可以决定B，这种不符合BC范式。
第四范式 ：消除关系中的多值依赖

并非范式越高越好，而是看哪种满足需求，范式越高的话表会越多，带来操作不便，一般情况下第三范式就已经满足需求。


二 数据库中用到的数据结构
1 各种树
二叉树    ：每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点；
           左子树和右子树是有顺序的，次序不能任意颠倒。
           
完全二叉树 ：对于一个树高为h的二叉树，其第0层至第h-1层的节点都满；
           如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。
           
二叉排序树 ：若左子树非空，则左子树上所有结点的值均小于根节点的值；
           若右子树非空，则右子树上所有结点的值均大于根节点的值；
           左右子树也都为二叉排序树
           
平衡二叉树 ：是一种特殊的二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。

满二叉树   ：叶子只能出现在最下一层；非叶子结点的度一定是2
           n层的完全二叉树有2的n次方减1个节点，总共有2的（n-1）次方个叶子节点。
           
B树       ：也称为B-树，对于一颗M阶的B树，树中的每个节点最多有m个孩子；
           除了根节点和叶子节点外，其他节点最少含有m/2（取上限）个孩子；
           若根节点不是叶子节点，则根节点最少含有两个孩子；
           所以叶子节点都在同一层，叶子节点不包含任何关键字信息，从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空，如果查找失败，则会返回叶子节点，即空指针。

B+树      ：B+树是B树的一种变形，它把数据都存储在叶子节点，内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点；
           B+树的遍历高效，将所以叶子节点串联成链表即可从头到尾遍历，
           磁盘系统常使用这种结构，mysql的InnoDB和myISAM都是使用的索引系统都是使用这种结构

红黑树     ：是一种特殊的二叉查找树，每个节点或者是黑色，或者是红色；
           根节点是黑色；
           每个叶子节点（NIL）是黑色，这里叶子节点，是指为空(NIL或NULL)的叶子节点；
           如果一个节点是红色的，则它的子节点必须是黑色的；
           从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
           红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍
           C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。
           时间复杂度O(logn)

B树和B+树的特点
B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。           


三 索引
索引实际上是一组指向表中数据的指针,索引的排列顺序其实就是这组指针的顺序，目的就是增加检索速度。

1 创建索引的原则
索引的数目不是越多越好。每个索引都需要占用磁盘空间；
为常作为查询条件的字段建立索引；
尽量使用数据量少的索引，如果索引的值很长，那么查询的速度会受到影响；
尽量选择区分度高的列作为索引，即重复值比较少；
尽量不要有NULL值，可以用默认值代替，null列是可以用到索引的但是不建议这样做，在使用mysql查询的时候可以使用explain select * from student where name is null,加上explain就可以看有没有走索引。

2 索引的分类
普通索引和唯一性索引 ：索引列的值的唯一性；
单个索引和复合索引   ：索引列所包含的列数；
聚集索引与非聚集索引 ：聚集索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储，非聚集索引的逻辑顺序与磁盘上行的物理存储顺序不同。。



四 事务
事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

事务的特征
原子性：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；
一致性：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；
隔离性：并发执行的事务之间不能相互影响；
持久性：事务一旦提交，对数据库中数据的改变是永久性的。


五 mysql数据库引擎
innoDB: 支持事物；行级锁；支持外键；旧版不支持全文索引，5.7以后的支持；索引使用B+树
MyISAM：不支持事物；表级锁；不支持外键；支持全文索引；索引使用B+树
全文索引：将创建索引的字段分词，然后按照词和记录建立索引对应关系，比如单词A对应第一条和第二条记录，单词B对应第二条和第四条记录。


六存储过程
存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能；
存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率。


七 触发器
触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合,用于保证数据的完整性。


八 超键、候选键、主键
超键  ：能唯一标示元组的属性关系
候选键：没有多余属性的超键
主键  ：选作元组标识的一个候选键

比如（学号，姓名、性别）
超级可以是（学号）、（学号、姓名）
候选键不能有多余属性，候选键只能是学号
主键就是学号